# Load specified SVD and generate peripheral memory maps & structures.
#@author Thomas Roth thomas.roth@leveldown.de
#@category leveldown security
#@keybinding 
#@menupath 
#@toolbar

# More information:
# https://leveldown.de/blog/svd-loader/
# License: GPLv3

from cmsis_svd.parser import SVDParser
from ghidra.program.model.data import Structure, StructureDataType, UnsignedIntegerDataType, DataTypeConflictHandler
from ghidra.program.model.data import UnsignedShortDataType, ByteDataType, UnsignedLongLongDataType
from ghidra.program.model.mem import MemoryBlockType
from ghidra.program.model.address import AddressFactory
from ghidra.program.model.symbol import SourceType
from ghidra.program.model.mem import MemoryConflictException

class MemoryRegion:
	def __init__(self, name, start, end):
		self.name = name
		self.start = start
		self.end = end

	def length(self):
		return self.end - self.start

def reduce_memory_regions(regions):
	for i in range(len(regions)):
		r1 = regions[i]
		for j in range(len(regions)):
			r2 = regions[j]
			# Skip self
			if i == j:
				continue
			if r1.end < r2.start:
				continue
			if r2.end < r1.start:
				continue

			# We are overlapping, generate larger area and call
			# reduce_memory_regions again.
			regions[i].start = min(r1.start, r2.start)
			regions[i].end = max(r1.end, r2.end)
			regions[i].name = r1.name + "_" + r2.name
			regions.remove(regions[j])
			return reduce_memory_regions(regions)
	return regions

def calculate_peripheral_size(peripheral, default_register_size):
	size = 0
	for register in peripheral.registers:
		register_size = default_register_size if not register._size else register._size
		size = max(size, register.address_offset + register_size/8)
	return size


svd_file = askFile("Choose SVD file", "Load SVD File")

print("Loading SVD file...")
parser = SVDParser.for_xml_file(str(svd_file))
print("\tDone!")

# CM0, CM4, etc
cpu_type = parser.get_device().cpu.name
# little/big
cpu_endian = parser.get_device().cpu.endian

default_register_size = parser.get_device().size

# Not all SVDs contain these fields
if cpu_type and not cpu_type.startswith("CM"):
	print("Currently only Cortex-M CPUs are supported.")
	print("Supplied CPU type was: " + cpu_type)
	sys.exit(1)

if cpu_endian and cpu_endian != "little":
	print("Currently only little endian CPUs are supported.")
	print("Supplied CPU endian was: " + cpu_endian)
	sys.exit(1)

# Get things we need
listing = currentProgram.getListing()	
symtbl = currentProgram.getSymbolTable()
dtm = currentProgram.getDataTypeManager()
space = currentProgram.getAddressFactory().getDefaultAddressSpace()

namespace = symtbl.getNamespace("Peripherals", None)
if not namespace:
	namespace = currentProgram.getSymbolTable().createNameSpace(None, "Peripherals", SourceType.ANALYSIS)

peripherals = parser.get_device().peripherals

print("Generating memory regions...")
# First, we need to generate a list of memory regions.
# This is because some SVD files have overlapping peripherals...
# (LPe) Memory regions are created based on the addressBlocks in a peripheral
memory_regions = []
for peripheral in peripherals:
	base = peripheral.base_address
	blknum=1
	for address_block in peripheral.address_blocks:
		start=base+address_block.offset
		length=address_block.size
		memRegionName="{:s}:AdrBlk#{:02X}".format(peripheral.name, blknum)
		memory_regions.append(MemoryRegion(memRegionName, start, start+length))
		blknum=blknum+1

memory_regions = reduce_memory_regions(memory_regions)

# Create memory blocks:
for r in memory_regions:
	try:
		addr = space.getAddress(r.start)
		length = r.length()

		t = currentProgram.memory.createUninitializedBlock(r.name, addr, length, False)
		t.setRead(True)
		t.setWrite(True)
		t.setExecute(False)
		t.setVolatile(True)
		t.setComment("Generated by SVD-Loader.")
	except Exception as e:
		print("\tFailed to generate memory block for: " + r.name)
		print("\t", e)

print("\tDone!")

print("Generating peripherals...")
for peripheral in peripherals:

	print("\t" + peripheral.name)
	if(len(peripheral.registers) == 0):
		print("\t\tNo registers.")
		continue
	if(len(peripheral.address_blocks) == 0):
		print("\t\tNo address blocks.")
		continue

	try:
	# Iterage through addressBlock of a Peripheral.
	# For each addressBlock create a pripheral strcuture with the name of the peripheral and the size of the actual addressBlock.
	# For each addessBlock iterate through the registers of the peripheral and add a register, if the offset mathes to the address range of the current addressBlock.
	# Enter the addressBlock specific peripheral to Ghidra.
	# Since all these addressBlock-peripheral entries share the same same, they pop up as one name in Ghidra.
	
		length = calculate_peripheral_size(peripheral, default_register_size)
		# Generate structure for the peripheral
		peripheral_struct = StructureDataType(peripheral.name, length)
		dtm.addDataType(peripheral_struct, DataTypeConflictHandler.REPLACE_HANDLER)

		baseAdr=peripheral.base_address
		for adrBlock in peripheral.address_blocks:
			addr = space.getAddress(baseAdr+adrBlock.offset)
			# Generate peripheral-strcuture for an address block
			peripheral_blk_struct = StructureDataType(peripheral.name, adrBlock.size)
			# iterate through all registers in the peripheral and add it to the addressBlock-peripheral structure
			# when the register is part of this addressBlock.
			for register in peripheral.registers:
				# check if the register is a member of the current addressBlock
				if ((register.address_offset>=adrBlock.offset) and (register.address_offset<adrBlock.offset+adrBlock.size) ):
					register_size = default_register_size if not register._size else register._size

					r_type = UnsignedIntegerDataType()
					rs = register_size / 8
					if rs == 1:
						r_type = ByteDataType()
					elif rs == 2:
						r_type = UnsignedShortDataType()
					elif rs == 8:
						r_type = UnsignedLongLongDataType()
					
					# please note: The address for registering here must be relative to the addressBlock address/offset
					peripheral_blk_struct.replaceAtOffset(register.address_offset-adrBlock.offset, r_type, register_size/8, register.name, register.description)
			#add this addressBlock-peripheral
			listing.createData(addr, peripheral_blk_struct, False)

		symtbl.createLabel(addr,
						peripheral.name,
						namespace,
						SourceType.USER_DEFINED );
	except:
		print("\t\tFailed to generate peripheral " + peripheral.name)
